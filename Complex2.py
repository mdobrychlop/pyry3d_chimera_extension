#!/usr/bin/env python
from __future__ import division
# -*- coding: utf-8 -*-
#
# 
# www.genesilico.pl 
#

#creates ranked 3D models of macromoleular complexes 
#based on experimental restraints and a whole complex shape.


__author__ = "Joanna M. Kasprzak"
__copyright__ = "Copyright 2010, The PyRy3D Project"
__credits__ = ["Janusz Bujnicki"]
__license__ = "GPL"
__version__ = "0.1.0"
__maintainer__ = "Joanna Kasprzak"
__email__ = "jkasp@amu.edu.pl"
__status__ = "Prototype"

#PyRy
from Modules.Error.Errors           import PyRyComplexError
from Modules.Trans.Component        import Component
#from Modules.Trans.RestraintChecker import PairRestraintChecker #, SingleComponentRestraintChecker
from Modules.Input.PyRyStructure    import PyRyStructure
from Modules.Trans.ComponentRepresentation import Grid #, scipyconverter
from Modules.Constans.Logfile       import logfile, trafl, outfolder
from Modules.Trans.RestraintFilters import *
from Modules.Trans.RestraintScorerFactory import RestraintScorerFactory

#check if needed/used within this module
from Bio.PDB                        import NeighborSearch
from Bio.PDB.Structure              import Structure
from Bio.PDB.Chain                  import Chain
from Bio.PDB.Model                  import Model
from Bio.PDB                        import PDBIO

from numpy                          import array
from random                         import randint
from math                           import sqrt, fabs

from itertools                      import combinations
from copy                           import deepcopy, copy


"""@TODO:
check names of methods and variables
remove code redundancy (has_changed, check_if_changed)
check private vs public methods!!
__str__ method
missing docstrings, descriptions etc
"""

class PyRyComplex(object):
    """
        class which represents complex structure generated by simulation
        each objt has different score and components coordinates but list of
        complex components is the same
    """
    
    def __init__(self, components = None, interactions = None):
        self.components         = components # contains all cmplx_components
        self.interactions       = interactions
        self.simulation_score   = 0.000   # float value
        
        self.volume             = 0.0     #complex volume
        self.vollist            = []      #to store MW of all cx residues
                                          #is deleted before simulation starts
        self.iteration_index    = 0       #number of simulation iteration when a particular complex was created                                          
        
#--------- simulation score weights -------------------------------
        self.collision_penalty  = 1.      #penalty for clashes given by the user in config file
        self.restraints_penalty = 1.      #penalty for restraints given by the user in config file
        self.freespace_penalty  = 1.      #penalty for freespaces given by the user in config file
        self.outbox_penalty     = 1.      #penalty for outbox given by the user in config file
        self.density_penalty    = 1.      #penalty for density given by the user in config file
        self.symmetry_penalty   = 1.      #should be used for optimalization only (for symmetrical complexes), value is provided by the user
        
#---------partial simulation scores---------------------------------
        self.temp               = 0.0     #actual simulation temperature
        self.reptemp            = 0.0     #temperature for given replica
        
        self.restraints         = 0.0     #final penalties for differences in distances between those given by the user and observed in the generated complex
        self.clashes            = 0.0     #final penalty for clashes between components
        self.outbox             = 0.0     #final penalty for atoms being outside the simulation box
        self.freespace          = 0.0     #final penalty for all empty grid cells inside density map and those corresponding to atoms outside the map   
        self.density            = 0.0     #final penalty for all empty grid cells inside density map (multiplied by density values from experiment) and those corresponding to atoms outside the map
        self.symmetry           = 0.0     #final penalty for violation of symmetry restraints
                
        self.all_restraints     = 0.       #temporal sum of restraints score comming from all components pairs
        self.all_clashes        = 0.       #temporal sum of clashes score comming from all components pairs
        self.all_filled_cells   = 0.       #temporal variable storing info how many grid cells are filled in a particular simulation step
        self.all_outbox_atoms   = 0.       #temporal sum of penalties comming from all complex atoms outside a simulation box

        
# ------------- cx atoms -----------------------------------------
        self.cxatoms            = 0        #number of atoms in a complex
        self.alfa_atoms_nr      = 0        #number of all calfa atoms in the complex (nr of residues)
        
# ------------- cx state ---------------------------------------
        self.movable            = []       #to store indexes (from self.components) of components that can be rotated or translated in simulation
        self.free               = []       #to store indexes of components with no limitations of movements assigned by the user
        self.with_disorders     = []
        self.changes            = []       #stores indexes (from self.components) of components changed during actual simulation step
        self.mode               = None     # "pyry3d" or "plugin"
        
# ------------------------------------------
        self.pairs_atoms        = 0        #to store number of atoms for all pairs in self.pairs
        self.pairs              = []       #stores all unredundant pairs of complex components indexes
        self.is_complex_outbox  = False    #to store state of the complex; False inside simul area; True outside
        
        #self.filled_mapcells    = 0        #number of grid cells required to describe all components (default constant value)
        self.mapcells_nr         = 0       #number of grid cells required to describe all components (default constant value)
        
        self.taken_mapcells     = {}       #stores indexes in the map which are occupied by all components
        self.taken_mapcells_coords = []    #used for PyRy Plugin only, stores XYZ coordinates of mapcells occupied by complex atoms
        self.is_complex_outmap = False     #True if any component is outside the shape of density map   
        self.taken_densities    = 0.       #sum of all density values occupied by given complex
        self.collided_atoms     = []       #list of collided atoms
        self.diffscores         = []       #list with data about current restraint score
        
        self.allthe_mapcells_coords = []


                        
    def __str__(self):
        return "%s %s" % (self.components, self.simulation_score)
    
    def deepcopy_score(self):
        
        temp = self.components
        self.components = None
        newone = deepcopy(self)
        self.components = temp
        newone.components = []
        for comp in temp:
            newone.components.append(comp)
        return newone
    
    def replace_component(self, comp_index, new_component):
        
        #print "przed zamiana", self.components
        #self.components[comp_index].pyrystruct.struct = new_component_struct
        self.components[comp_index] = new_component
        #print "po zamianie", self.components[comp_index].pyrystruct.chain, self.components[comp_index].pyrystruct.struct
    
    def add_complex_alfa_atoms(self, alfa_atoms):
        self.alfa_atoms_nr += alfa_atoms
    
    def add_complex_atoms(self, atoms_nr):
        self.cxatoms += atoms_nr
        
    def add_component(self, component):
        self.components.append(component)
    
    def add_movable_component(self, component):
        """
           if component is able to be moved during simulation it is added
           to a list of movable simulation objects
           self.movable contains only indexes to components in self.components
           to provide faster iteration and copy making
        """
        if component.moves.state != "fixed":
            self.movable.append(self.components.index(component))
        if component.moves.limited == False and component.moves.state != "fixed" and len(component.covalent_bonds) == 0:
            self.free.append(self.components.index(component))
        if len(component.disorders) != 0: self.with_disorders.append(self.components.index(component))
        #print "components DDDDD", component.pyrystruct.chain, len(component.disorders), self.components.index(component)
    
    def add_simul_change(self, component):
        """
            adds one chain to changed components
            @REMINDER for first complex all components should be treated as changed
        """
        self.changes.append(self.components.index(component))
        
    def add_simul_change_by_index(self, component_index):
        """
            adds one chain to changed components
            @REMINDER for first complex all components should be treated as changed
        """
        self.changes.append(component_index)    
        
    def add_trajectory(self, iter_nr, temp):
        """
            adds particular complex coordinates into trajectory file
        """
        
        logfile.write_message("cx score "+str(round(self.simulation_score,3))+"\tcomponents "+\
                         str(round(self.restraints,3) * self.restraints_penalty)+" "+\
                         str(round(self.clashes,3)    * self.clashes_penalty)+" "+\
                         str(round(self.freespace,3)* self.freespace_penalty)+" "+\
                         str(round(self.outbox,3)     * self.outbox_penalty)+" "+\
                         str(round(self.density,3)  * self.density_penalty)+" "+\
                         str(round(self.symmetry,3)  * self.symmetry_penalty))
        
        
        trafl.write_message(str(iter_nr)+" "+str(iter_nr)+" "+str(self.simulation_score)+" "\
                                 +str(self.simulation_score)+" "+str(temp))
        
        coordinates = ""
        for structure in self.components:
            for at in structure.pyrystruct.struct.get_atoms():
                coordinates += str(at.coord[0])+" "+str(at.coord[1])+" "+str(at.coord[2])+" "
        trafl.write_message(coordinates)        
        trafl.write_file()
        
    def assign_new_taken_indexes(self):
        """
           creates a list of indexes for mapcells which are already occupied
           by components only unchanged components are considered!
        """
        self.taken_mapcells = {}
        if self.mode == "plugin":
            self.taken_mapcells_coords = []

        for index in xrange(0, len(self.components)):
            if not self.has_changed(index):
                self.taken_mapcells.update(self.components[index].taken_mapcells)
                
                if self.mode == "plugin":
                    self.taken_mapcells_coords.extend(self.components[index].taken_mapcells_coords)

            else:
                self.get_alfa_atoms(self.components[index])
                if self.mode == "plugin":
                    will_remove = []
                    for d in self.diffscores:
                        if self.components[index].pyrystruct.chain in d.chains:
                            will_remove.append(d)
                    for w in will_remove:
                        self.diffscores.remove(w)
                    
            
    def assign_scores(self, dmap, flag = None):
        """
           calculates final score values based on precalculated values
           
           if flagname is given than scoresare assigned only for complexes
           composed of a single component
        """
        #do not calculate these parts for one-component systems.
        if flag == None:
            self.clashes = -(self.all_clashes/(self.pairs_atoms)) *100.0  
        #assign final score values (percentage)
        self.outbox      = -(self.all_outbox_atoms/(self.alfa_atoms_nr))*100

        #how many mapcells are occupied by atoms positioned outside the density map
        outatoms_cells   = (self.mapcells_nr - self.all_filled_cells)
        #how many mapcells are empty (not ocupied by any complex atom)
        empty_mapcells   = (len(dmap.mapgrid.mapcells)  - self.all_filled_cells)
        #how many mapcells are necessarily to describe whole map and all complex components together
        all_cells        = (self.mapcells_nr + len(dmap.mapgrid.mapcells))       
        
        #when modeling with no shape descriptor..
        if self.freespace_penalty != 0:
            self.freespace = -(((outatoms_cells+empty_mapcells)/all_cells))*100.       
        
        #do not score densities for SAXS!!
        if dmap.density_sum != 0:
            self.density   = -((dmap.density_sum - self.taken_densities)/\
                                                   dmap.density_sum)*100. 
        else:
            self.density = 0.
            
        for i in dmap.mapgrid.mapcells:
            self.allthe_mapcells_coords.append(i.coord)
                                
    def calculate_complex_volume(self):
        """
            calculates a sum of volumes for all complex components
            this measure is used to calculate proper density map shape
        """
        for comp in self.components:
            self.volume += comp.volume
            self.vollist = self.vollist + comp.vollist
            
    def calculate_outbox_mapfill(self, interactions, dmap, simul_params):
        """
           calls methods to calculate clashes and filling a density map by
           components and adds these scores into global punctation
           
           procedure is applied only to components changed during actual
           iteration of simulation
        """
        #print "Changed components", self.changes
        for mol in self.changes:
            
            component = self.components[mol]
            #substract old values from scores

            self.all_outbox_atoms   -= component.outbox_atoms
            #self.all_filled_cells   -= (len(component.taken_mapcells))
            self.all_restraints      = self.all_restraints**2 - abs(component.sa_interactions_score)
            self.all_restraints      = self.all_restraints - abs(component.pd_interactions_score)
            #self.taken_densities    -= component.taken_density
    
            
            #calculate new score elements#
            self.__calculate_outbox_score(component, dmap)

            self.__calculate_empty_mapspaces_score(component, dmap, simul_params)
            
            #
            #add new scores to whole complex score
            self.all_outbox_atoms   += component.outbox_atoms
            self.all_filled_cells   = len(self.taken_mapcells)
            self.all_restraints      = self.all_restraints + abs(component.sa_interactions_score)
            self.all_restraints      = sqrt(self.all_restraints + abs(component.pd_interactions_score))
            
            self.taken_densities    = sum(self.taken_mapcells.values())
            print "SUMA", self.taken_densities

                
    def calculate_restraints_clashes(self, interactions, simul_params):
        """
           calls methods to calculate clashes and filling a density map by
           components and adds these scores into global punctation
           
           procedure is applied only to pair of components changed during actual
           iteration of simulation
        """
        for p in self.pairs:
            if self.check_if_changed(p.pair):
                self.all_clashes    -= p.clashes_nr
                #calculate new score elements#
                st1, st2 = self.get_pair_components(p)
                self.__calculate_clashes_score(st1, st2, p, simul_params)
                self.all_clashes    += p.clashes_nr
                
    def calculate_score_for_one_component_complex(self, interactions, dmap, simul_params):
        """
        calculate simulation score when complex is built of one component only
        """
        self.calculate_outbox_mapfill(interactions, dmap, simul_params)
        self.assign_scores(dmap, "one_component")
        self.assign_new_taken_indexes()
        self.simulation_score =    (self.restraints_penalty  * self.restraints)+\
                                    (self.clashes_penalty    * self.clashes)+\
                                    (self.freespace_penalty  * self.freespace) +\
                                    (self.outbox_penalty     * self.outbox) +\
                                    (self.density_penalty    * self.density +\
                                     self.symmetry_penalty   * self.symmetry)
        
        print "ONE component score", round(self.simulation_score,3), "components ", round(self.restraints,3),\
                            round(self.clashes,3),  round(self.freespace,3), round(self.outbox,3), round(self.density,3)
            
    def calculate_simulation_score(self, interactions, dmap, simul_params, \
                                   mode = "pyry3d", iteration = "regular_complex"):
        """
            calculates score for complex which is inside simulbox
        takes all scores:
            -for collisions
            -for restraints
            -for fitting density map
            -for being inside a simulbox
        and calculates final common score which takes into consideration
        weights of all these measures
        """
        self.mode = mode #can be "pyry3d" for regular/normal simulation and "plugin" for calculations implemented in PyRy3D Plugin
        
        self.update_restraints_score()
        self.restraints = -1. * self.calculate_restraints_score()
        self.symmetry = -1. * self.calculate_symmetry_score()

        if len(self.components) == 1:
            self.calculate_score_for_one_component_complex(interactions, dmap, simul_params)            
        else:
    # -------- reassign taken mapcells (clean indexes occupied by component changed in particular simulation step) -------
            self.is_complex_outbox = False
            self.is_complex_outmap = False
            self.assign_new_taken_indexes()
 
    # ----------- calculate empty spaces and position within simulbox ------------
            self.calculate_outbox_mapfill(interactions, dmap, simul_params)
  
    #------calculate restraints and clashes only if components are inside simbox--------
            self.calculate_simulation_score_for_complex(interactions, dmap, simul_params)

        for c in self.components:
            self.clean_alfa_atoms(c)
   
                
    def calculate_simulation_score_for_complex(self, interactions, dmap, simul_params): # complex_type = "inbox"):
        """
        """
        
        
        #-----is outside the simulation box?------
        is_outbox = 0    #how many components are outside the simulation area
        
        
         #-----is outside the density map?------
        is_outmap = 1    #how many components are outside the density map
        
        for comp in self.components:
            if comp.is_outbox == True:
                is_outbox += 1
                self.is_complex_outbox = True
            if comp.is_outmap == True:
                is_outmap += 1
                self.is_complex_outmap = True
        
        self.calculate_restraints_clashes(interactions, simul_params)
        
# ------ sum up values of scoring function elements -----------------
        self.assign_scores(dmap)
        
# ----------- sumarize all scoring function components --------------
        self.simulation_score = (self.restraints_penalty * self.restraints)+\
                                (self.clashes_penalty    * self.clashes)+\
                                (self.freespace_penalty  * self.freespace) +\
                                (self.outbox_penalty     * self.outbox) +\
                                (self.density_penalty    * self.density +\
                                 self.symmetry_penalty   * self.symmetry )
        #if complex_type == "outbox":
        #    self.simulation_score += 100*self.outbox
        if self.is_complex_outbox == True:
            print "COMPLEX IS OUTSIDE THE SIMULATION AREA!!!"
            self.simulation_score += 100*is_outbox*self.outbox
        if self.is_complex_outmap == True:
            print "COMPLEX IS OUTSIDE THE SHAPE OF DENSITY MAP!!!!"
            self.simulation_score += 100*is_outmap*self.density
            self.simulation_score += 100*is_outmap*self.freespace
            
        print "%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t"% (round(self.simulation_score,3) , \
                       round(self.restraints,3) * self.restraints_penalty,\
                       round(self.clashes,3)    * self.clashes_penalty,  \
                       round(self.freespace,3)  * self.freespace_penalty, \
                       round(self.outbox,3)     * self.outbox_penalty,\
                       round(self.density,3)    * self.density_penalty, \
                       round(self.symmetry,3)   * self.symmetry_penalty)
                
    def check_if_changed(self, pair):
        """
           checks whether any of particular pair of components was moved
           in a given simulation step
@TODO ------ can these two be merged into one method somehow? with has_changed----------- 
        """
        if len(self.changes) == 0: return True
        for changed in self.changes:
            if pair[0] == changed or pair[1] == changed: return True
            
    def clean_alfa_atoms(self, component):
        component.alfa_atoms = []
        
    def clean_simul_changes(self):
        self.changes = [] #clear changes from previous simul iteration
        
    def clean_vollist(self):
        """
        when vollist is not used any more, delete it so that it is not copied
        during simulation
        """
        del self.vollist
        
    def exchange_components(self, comp1, comp2, history = True):
        """
        exchanges location within a map between 2 components after change comp1
        is located where comp2 was before mutation
        """        
        trans_vector1 = array(comp1.mass_centre) - array(comp2.mass_centre)
        trans_vector2 = array(comp2.mass_centre) - array(comp1.mass_centre)
        
        #translate structure
        comp1.translate(trans_vector2,history)
        comp2.translate(trans_vector1, history)
            
        #print "Exchange", comp1.pyrystruct.chain, comp2.pyrystruct.chain 
        
        
    def generate_comp_pairs(self):
        """
        genrerates unredundant list of components pairs e.g for A, B, C it is [[A,B], [A,C], [B,C]]
        list represents possible interactions between complex components
        function should be called only during creation of first complex!
        """
        #generate unique pairs of components (combinations)
        pairs = list((combinations(xrange(0, len(self.components)),2)))

        for c1, c2 in pairs:
            #longer first, because it gives better results in NeighSearch
            if len(list(self.components[c1].pyrystruct.struct.get_atoms())) >= \
               len(list(self.components[c2].pyrystruct.struct.get_atoms())): 
                 p = ComponentPair()
                 p.set_pair_components(c1,c2)
                 self.pairs.append(p)
            else:
                 p1 = ComponentPair()
                 p1.set_pair_components(c2,c1)
                 self.pairs.append(p1)
            #collect number of all alfa atoms for a given pair of components
            self.pairs_atoms += len(list(self.components[c1].alfa_atoms)) + \
                                len(list(self.components[c2].alfa_atoms))

    def get_alfa_atoms(self, component):
        """
        clean old alfa atoms (C4' for nucleic acids and CA for proteins)
        and replace them with mutated counterparts
        Parameters:
        -----------
            component : component object
        """
        self.clean_alfa_atoms(component)
        for at in component.pyrystruct.struct.get_atoms():
            if at.name == "CA" or at.name == "C4'" or at.name == "C4*": component.add_alfa_atom(at)
        if len(component.alfa_atoms) == 0:
            raise PyRyComplexError("In structure %s you provided there are no\
                                   Calfa or C4' atoms!!"%(component.pyrystruct.chain))
                
    def get_component_by_chain(self, chainName):
        """
        returns Component based on a given chain name or None if it does not exist
        """
        for component in self.components:
            if component.pyrystruct.chain == chainName:
                return component
        return None
        
    def get_component_index_by_chain(self, chainName):
        """
        returns an index of a Component based on a given chain name or -1 if it does not exist
        """
        index = -1
        for component in self.components:
            index+=1
            if component.pyrystruct.chain == chainName:
                break
        return index
        
    def get_pair(self, chainA, chainB):
        """
        returns ComponentPair based on given chain names or None if it does not exist
        """
        componentIndexA = self.get_component_index_by_chain(chainA)
        componentIndexB = self.get_component_index_by_chain(chainB)
        for pair in self.pairs:
            if componentIndexA in pair.pair and componentIndexB in pair.pair:
                return pair
        return None
        
    def get_pair_components(self, pair):
        """
        returns Component objects for given pair of indexes e.g.
        for [1, 2] returns component1 and component2 from self.components
        """
        st1 = self.components[pair.pair[0]]
        st2 = self.components[pair.pair[1]]
        return st1, st2
                
    def get_simboxcells(self, dmap):
        """
        calculates how many grid cells are nedded for all complex components and
        a density map called once only while first complex is created!!

        method calculates how many simgrid cells are occupied by
        all complex atoms
        Parameters:
        -----------
            map   - density map
        """
        occupied_cells = 0 #[]                    #counter of occupied grid cells
        for comp in self.components:
            cells_taken_by_component = self.__calculate_separate_simbox_statistics(comp, dmap.mapgrid.radius) #, cells_taken_by_component)
            occupied_cells += cells_taken_by_component
            comp.set_mapcells_nr(cells_taken_by_component)
        self.mapcells_nr = occupied_cells
        
    def has_changed(self, index):
        """
        checks whether a given component was moved in actual simulation step
@TODO ------ can these two be merged into one method somehow? with check_if_changed----------- 
        """            
        for changed in self.changes:
            if index == changed: return True
            
    def save_pdb(self, complex_id, temp = "", name = ""):
        """
        gets coordinates of all complex components and writes them in one
        file one component = one pdb model
        
        Parameters:
        ------------
            complex_id  : number of complex from simulation
        Returns:
        --------
            pdb files with simulated components in OUTFOLDER
        """
        ##add component chain by chain not residue by residue.
        model_num = 0
        score = round(self.simulation_score, 4)
        s = Structure(complex_id) 
        my_model = Model(0)
        s.add(my_model)
        
        for component in self.components:
#@TODO: #what if more chains in one component?
            my_model.add(component.pyrystruct.struct[0][component.pyrystruct.chain])
        out = PDBIO()
        out.set_structure(s)
        outname = outfolder.outdirname.split("/")[-1]
        if name:
            out.save(str(outfolder.outdirname)+'/'+name+'_'+str(score)+'_'+str(complex_id)+"_"+str(temp)+'.pdb')
        else:
                        
            out.save(str(outfolder.outdirname)+'/'+str(outname)+"_"+str(score)+'_'+str(complex_id)+"_"+str(temp)+'.pdb')
            
        for comp in self.components:
            comp.pyrystruct.struct[0][comp.pyrystruct.chain].detach_parent()
        
            
    def search_neighbours(self, point, radius, ns):
        """
        performs Neighbor Search procedures
        """
        center = array([point.coord[0], point.coord[1], point.coord[2]])
        neighbours = ns.search(center, radius,'A')
        #neighbours = ns.run_neisearch(center, radius)
        return neighbours
    
    def set_penalties_weights(self, collision_penalty, restraints_penalty, \
                                    free_space_penalty, out_box_penalty, density_penalty, symmetry_penalty):
        """
        sets weights for scoring function elements
        """
        self.clashes_penalty    = collision_penalty
        self.restraints_penalty = restraints_penalty
        self.freespace_penalty  = free_space_penalty
        self.outbox_penalty     = out_box_penalty
        self.density_penalty    = density_penalty
        self.symmetry_penalty   = symmetry_penalty
                
    def set_iteration_index(self, index):
        """
        sets iteration_index which indicates simulation number
        """
        self.iteration_index = index
        
    def set_annealing_temp(self, atemp):
        self.temp = atemp
    
#---- Private methods-------

    def __calculate_clashes_score(self, struct1, struct2, p, simul_params):
        """
        calculates punish for clashes for a given complex structure    
        """
        if self.clashes_penalty != 0:
            clashes_num, collided  = 0, {} #[]      
            self.get_alfa_atoms(struct1)
            
            #scitree = scipyconverter(struct1.alfa_atoms)
            #option for checking clashes between all atoms in the complex - comment next line; uncomment the following
            
            if simul_params.required_clashes_penalty:
                ns = NeighborSearch(struct1.alfa_atoms)
            #for checking collisions between all atoms, not only main chain:
            elif simul_params.required_clashes_penalty_allatoms:
                ns = NeighborSearch(list(struct1.pyrystruct.struct.get_atoms()))
            
            if self.mode == "plugin": p.clean_collided_atoms()
            
            for at in struct2.pyrystruct.struct.get_atoms():
                #option for checking clashes between all atoms in the complex - comment next line
                if simul_params.required_clashes_penalty:
                    if at.name == "CA" or at.name == "C4'" or at.name == "C4*": pass
                    else: continue
                center = at.coord
                
                if simul_params.required_clashes_penalty:
                    if at.name == "CA": neighbours = ns.search(center, 5.0, "A")
                    else: neighbours = ns.search(center, 6.0, "A") #6.12 for RNA and 5.8 for DNA (mean distance between C4')
                elif simul_params.required_clashes_penalty_allatoms:
                    #option for checking clashes between all atoms in the complex
                    neighbours = ns.search(center, at.vdw * 2.01, "A")
                
                #neighbours = scitree.run_neisearch(center, 5.0, eps=0)
                
                if len(neighbours) != 0:
                    for nei in neighbours:
                        collided[nei.get_serial_number()] = "1"
                    clashes_num = len(collided)*2
                        
                        #if nei not in collided:
                        #    clashes_num += 2 #len(neighbours) + 1
                        #    collided.append(nei)
                            
                #number of collided atoms plus atom from iterated structure
                if self.mode == "plugin":
                    if len(neighbours) !=0:
                        for nei in neighbours:
                            p.struct1_collided_atoms[nei.serial_number] = "1"
                        p.struct2_collided_atoms[at.serial_number]  = "1"
                        #
                        #
                        #for nei in neighbours:
                        #    if nei not in p.struct1_collided_atoms:
                        #        p.struct1_collided_atoms.append(nei.serial_number)
                        #p.struct2_collided_atoms.append(at.serial_number)
                neighbours = []
            p.set_clashes_nr(clashes_num) 

        
    def __calculate_empty_mapspaces_score(self, component, dmap, simul_params):
        """
        for a particular component method checks which of its atoms
        are inside a density map and returns them as a list
        Arguments:
        ----------
            component          -  one single complex component (single molecule)
        """
        #print "EMPTY MAPSPACES!!!", len(list(component.pyrystruct.struct.get_atoms())), component.pyrystruct.chain
        
        #scitree = scipyconverter(dmap.simgrid.mapcells)
        if self.mode == "plugin":
            component.inmap_atoms = []
        
        #calculate this score only if shape is provided and penaltis for shape scoring is assigned
        if self.freespace_penalty != 0 or self.density_penalty !=0 or simul_params.shapedesc == True:
            #print "###########", self.freespace_penalty, self.density_penalty, simul_params.shapedesc
            component.clean_taken_mapcells()    #since a component was changes gridcells taken by it must be deleted and checked again
            #component.taken_density = 0.
                        
            for atom in component.pyrystruct.struct.get_atoms():
                if atom.vdw <= dmap.mapgrid.radius: radius = dmap.mapgrid.radius* sqrt(3)
                else: radius = (dmap.mapgrid.radius*sqrt(3)) + atom.vdw
                
                neigh = self.search_neighbours(atom, radius, dmap.ns_mapgrid)
                
                self.__calculate_fitness_statistics(neigh, component)
                if self.mode == "plugin":
                    if len(neigh) != 0:
                        component.inmap_atoms.append(atom.serial_number)
            component.outmap_cells = component.mapcells_nr - (len(component.taken_mapcells))
            self.taken_mapcells.update(component.taken_mapcells)
            
            #if the whole component is outside the density map assign additional penalty as for outbox components
            if component.outmap_cells == component.mapcells_nr:
                component.is_outmap = True
                print "COMPONENT OUTMAP!!!!", component.is_outmap, component.outmap_cells
                #print "Component, score", component.pyrystruct.chain,  self.is_complex_outmap, component.outmap_cells, component.mapcells_nr
            else:
                component.is_outmap = False
                
            #component.mapcells_nr   - how many mapcells are necessarily to describe this particular component
            #component.taken_mapcells - how many mapcells are occupied by a particular component in this simulation iteration

#--- do not calculate restraints when its weight is 0 ---------------            
        elif self.freespace_penalty == 0 or self.density_penalty == 0:
            pass
        
    def __calculate_fitness_statistics(self, neigh, component):
        """
           for each atom of given component the method
           takes mapcells identified by NeighbourSearch and calculates number of mapcells occupied by given
           component. If some mapcells were already occupied by other atoms they are ignored
           and not considered for this particular atom again
           
           neigh - list of density map cells identified as neighbours for an atom of interest (result of NeighbourSearch)
        """
        if len(neigh) != 0:
            for mappoint in neigh:
                component.taken_mapcells[mappoint.index] = mappoint.density    #append(mappoint.index)
                
                if self.mode == "plugin":
                    self.taken_mapcells_coords.append(mappoint.coord)
                    component.taken_mapcells_coords.append(mappoint.coord)
                    #add taken mapcells to component fitness
                    #component.taken_mapcells.append(mappoint.index)
                    
                    #component.taken_density += mappoint.density
                    #print "SPHERE,", mappoint.coord[0], ",",mappoint.coord[1],",", mappoint.coord[2], ",", 0.8, ","

    def __calculate_separate_simbox_statistics(self, component, radius): #, cells_taken_by_component):
        """
        calculates the number of grid cells describing each complex component.
        calculation is done when all components are located in the center of simulation box
        """
        self.cells_taken_by_component = {}
        grid = Grid("cubic", radius, 10*radius, -1.)
        grid.calculate_boundaries(component.pyrystruct.struct)
        grid.generate_cubic_grid([])
        
        #scitree = scipyconverter(grid.grid_cells)
        ns = NeighborSearch(grid.grid_cells)
                    
        for atom in component.pyrystruct.struct.get_atoms():
            center = array([atom.coord[0], atom.coord[1], atom.coord[2]])
            if atom.vdw <= radius: rad = radius* sqrt(3)
            else: rad = (radius*sqrt(3)) + atom.vdw
            neighbours = ns.search(center, rad, 'A') #atom.vdw + radius
            #neighbours = scitree.run_neisearch(center, rad, eps=0)
            self.cells_taken_by_component = self.__calculate_simbox_statistics(neighbours) #, cells_taken_by_component)
            if len(neighbours) == 0: print "OMGOMG"*10, component.pyrystruct.chain, atom.serial_number
         
        del grid
        del ns
        neighbours = []
        return len(self.cells_taken_by_component)
        
    def __calculate_outbox_score(self, component, dmap):
        """
        calculates punish for being outside the simulbox
        punish is calculated for alfa atoms only to minimize number of calculations   
        Parameters:
        -----------
            component   : complex_component object
        """
        #print "OUTBOX SCORING..", len(component.alfa_atoms), component.pyrystruct.chain
        if self.mode == "plugin": component.outbox_atoms_li = []
        if self.outbox_penalty != 0:
            outbox_atoms = 0
            for atom in component.pyrystruct.struct.get_atoms():
                if atom.name == "CA" or atom.name == "C4'" or atom.name == "C4*":
                    if dmap.is_inside(atom, dmap.simulbox) == False:
                        outbox_atoms += 1
                        if self.mode == "plugin":
                            component.outbox_atoms_li.append(atom.serial_number)
                        #print "outside!!!", component.pyrystruct.chain, atom.id
                    #if self.mode == 'simul_complex_scoring':
                        #if outbox_atoms >= 0.6 * len(component.alfa_atoms): 
                        #    print "Component outside simulbox", component.pyrystruct.chain, outbox_atoms, len(component.alfa_atoms)
                        #    component.outbox_atoms = len(component.alfa_atoms)
                        #    self.is_complex_outbox = True
                        #    return 1
                    #elif self.mode == 'single_complex_scoring': pass
            if outbox_atoms >= 0.6 * len(component.alfa_atoms):
                print "COMPONENT OUTSIDE THE SIMULATION BOX", component.pyrystruct.chain, outbox_atoms, len(component.alfa_atoms)
                component.is_outbox = True
                #self.is_complex_outbox = True
            else:
                component.is_outbox = False
            component.outbox_atoms = outbox_atoms
            #print "OUTBOX SCORING..", component.outbox_atoms, component.pyrystruct.chain
            
                                
#--- do not calculate restraints when outbox' weight is 0 ---------------
        if self.outbox_penalty == 0:
            pass
    
    def update_restraints_score(self):
        scorerFactory = RestraintScorerFactory(self)
        scorers = []
        changes = []
        for change in self.changes:
            changes.append(self.components[change].pyrystruct.chain)
        filter = RestraintFilter(changes)
        filtered = filter(self.interactions.all)
        for restraint in filtered:
            scorer = scorerFactory.createScorer(restraint)
            if scorer:
                scorers.append(scorer)
                scorer.score()

    def calculate_restraints_score(self):
        score = 0.0
        filter = RegularRestraintFilter()
        filtered = filter(self.interactions.all)
        for restraint in filtered:
            score += restraint.get_score()**2
        return sqrt(score)

    def calculate_symmetry_score(self):
        product = 1.0
        score = 0.0
        filter = SymmetryRestraintFilter()
        filtered = filter(self.interactions.all)
        if len(filtered) == 0:
            return 0.0
        for restraint in filtered:
            product *= restraint.get_score()
            average = pow(product, 1.0/len(filtered))
        for restraint in filtered:
            score += fabs(restraint.get_score() - average)
        return score
    
    

#probably not used any more after changes applied to Restraints mode        
    def set_pair_score(self, diffscores):
        if len(diffscores):
            pair = self.get_pair(diffscores[0].chains[0], diffscores[0].chains[1])
            rest_score = 0.0
            for diff in diffscores:
                rest_score += (fabs(diff.dif))**2
            pair.set_restraint_score(rest_score)
    #def save_diffscore(self, diffscores):
    
        if self.mode == 'plugin':
            self.diffscores += diffscores
            
    def set_symmetric_score(self, distances):
        print distances
    
    def __calculate_simbox_statistics(self, neigh): #, cells_taken_by_component):
        """
        """
        if len(neigh) != 0:
            for mp in neigh:
                #if 2 atoms of given comp fill the same cell - take one cell only
                #if mp.index not in cells_taken_by_component:
                #    cells_taken_by_component.append(mp.index)
                self.cells_taken_by_component[mp.index] = "1"
        return self.cells_taken_by_component
        
    def __choose_radius(self, radius1, radius2):
        """
        choose larger radius between 2 values
        """
        return max([radius1, radius2])
    
################ helping class ###########################################

class ComponentPair:
    """
       represents each interacting pair of complex components
       stores information about clashes number in particular simulation iteration
    """
    def __init__(self):
        self.pair = []               #eg [A,B]
        self.clashes_nr = 0          #number of collided atoms
        self.restraint = 0.0         #keeps score for restraints
        self.symmetry  = 0.0         #keeps score fot symmetry restraints
        self.struct1_collided_atoms = {} #[] #keeps serial numbers of first pair component of collided atoms
        self.struct2_collided_atoms = {} #[]
        
    def clean_collided_atoms(self):
        self.struct1_collided_atoms = {} #[]
        self.struct2_collided_atoms = {} #[]
    
    def set_pair_components(self, comp1, comp2):
        self.pair.extend([comp1, comp2])

    def set_clashes_nr(self, number):
        self.clashes_nr = number

    def set_restraint_score(self, rest_score):
        self.restraint = rest_score

    def set_symmetry_score(self, sym_score):
        self.symmetry = sym_score  #list of scores